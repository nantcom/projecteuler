using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Diagnostics;
using System.Text;
using System.Dynamic;
using NantCom;
using NantCom.DataStructure.Tree;

namespace ProjectEuler.Test
{

    [TestClass]
    public class Problems1to10
    {
        [TestMethod]
        [TestCategory("01-10")]
        public void Problem1()
        {
            /*
             * If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
             * Find the sum of all the multiples of 3 or 5 below 1000.*/
            Func<int, int> sumMultipleOf3and5 = (max) =>
            {
                var sum = 0;
                for (int i = 0; i < max; i++)
                {
                    if (i % 3 == 0 || i % 5 == 0)
                    {
                        sum += i;
                    }
                }

                return sum;
            };

            /* BEST Performance O(1)
             * 
             * แปลงเลข ให้อยู่ในรูป 1+2+3+4.... (เข้าสมการ Zigma)
             * 3+6+9+12.....999
             * หาร 3
             * 1+2+3+4......333
             * แล้วเอาเลขนี้ เข้าสูตร Zigma จากนั้น คุณ 3 กลับเข้าไป
             * 
            target=999
                Function SumDivisibleBy(n) 
             *      p=target div n  return n*(p*(p+1)) div 2
             *  EndFunction
            Output SumDivisibleBy(3)+SumDivisibleBy(5)-SumDivisibleBy(15) 
             * 
            */

            //Assert.IsTrue(sumMultipleOf3and5(10) == 23, "Sum of number < 10 must be 23");
            Assert.IsTrue(sumMultipleOf3and5(1000) == 233168, "Sum of number < 1000 must be 233168");
        }

        [TestMethod]
        [TestCategory("01-10")]
        public void Problem2()
        {
            /*
             * Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

                1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

                By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
            */

            var n1 = 1;
            var n2 = 2;
            var current = 0;
            var sum = 0;

            sum += 2;

            do
            {
                current = n1 + n2;

                n1 = n2; // move previous number by 1
                n2 = current; // move previous number by 1

                if (current % 2 == 0)
                {
                    sum += current;
                }

            } while (current < 4000000);

            Assert.IsTrue(sum == 4613732, "Wrong Answer");
        }

        [TestMethod]
        [TestCategory("01-10")]
        public void Problem3()
        {
            /* The prime factors of 13195 are 5, 7, 13 and 29.

                What is the largest prime factor of the number 600851475143 ?
                */

            Func<long, bool> isPrime = (n) =>
            {
                var hasFactor = 2L.To(n - 1).Any((i) =>
                {
                    return n % i == 0;
                });
                return !hasFactor;
            };

            //Assert.IsTrue(isPrime(13), "13 is prime");

            Func<long, IEnumerable<long>> findFactorsFromLargest = (n) =>
            {
                long maxFactor = (long)Math.Sqrt(n);
                return (maxFactor).To(2).Where((i) => n % i == 0);
            };

            //var factors = findFactorsFromLargest(13195).ToArray();
            //Assert.IsTrue(factors[0] == 5, "First Factor is 5");
            //Assert.IsTrue(factors[1] == 7, "First Factor is 7");
            //Assert.IsTrue(factors[2] == 13, "First Factor is 13");
            //Assert.IsTrue(factors[3] == 29, "First Factor is 29");

            var answer = findFactorsFromLargest(600851475143).Where(i => isPrime(i)).First();
            Assert.IsTrue(answer == 6857, "Wrong Answer");
        }

        [TestMethod]
        [TestCategory("01-10")]
        public void Problem4()
        {
            /*
             A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

                Find the largest palindrome made from the product of two 3-digit numbers.
             */

            Func<long, bool> isPalinDrome = (i) =>
            {
                var forward = i.ToString();
                var backwards = new String(i.ToString().Reverse().ToArray());

                return forward.Equals(backwards);
            };

            Func<string, bool> print = (s) =>
            {

                Debug.WriteLine(s);
                return true;
            };

            Assert.IsTrue(isPalinDrome(1991), "1991 is Palindrome");

            var allPossible = from lhs in 999L.To(900)
                              from rhs in 999L.To(900)
                              let result = lhs * rhs
                              //let printA = print( string.Format("{0} x {1} = {2}", lhs, rhs, result )) 
                              where result > 900009 && isPalinDrome(result)
                              select result;

            var largest = allPossible.Max();
            Assert.IsTrue(largest == 906609, "Wrong Answer");
        }
        
        [TestMethod]
        [TestCategory("01-10")]
        public void Problem8()
        {
            var data =
@"73167176531330624919225119674426574742355349194934
 96983520312774506326239578318016984801869478851843
 85861560789112949495459501737958331952853208805511
 12540698747158523863050715693290963295227443043557
 66896648950445244523161731856403098711121722383113
 62229893423380308135336276614282806444486645238749
 30358907296290491560440772390713810515859307960866
 70172427121883998797908792274921901699720888093776
 65727333001053367881220235421809751254540594752243
 52584907711670556013604839586446706324415722155397
 53697817977846174064955149290862569321978468622482
 83972241375657056057490261407972968652414535100474
 82166370484403199890008895243450658541227588666881
 16427171479924442928230863465674813919123162824586
 17866458359124566529476545682848912883142607690042
 24219022671055626321111109370544217506941658960408
 07198403850962455444362981230987879927244284909188
 84580156166097919133875499200524063689912560717606
 05886116467109405077541002256983155200055935729725
 71636269561882670428252483600823257530420752963450";

            var numbers = (from c in data
                           where char.IsDigit(c)
                           select (long)(c - 48)).ToList();

            Assert.IsTrue(numbers.Last() == 0, "Wrong Conversion");

            var max = 0L;
            IEnumerable<long> resultSeries = null;
            for (int i = 0; i < numbers.Count; i++)
            {
                var product = numbers.Skip(i).Take(13).Product();
                if (product > max)
                {
                    max = product;
                    resultSeries = numbers.Skip(i).Take(13).ToArray();
                }
            }

            Assert.IsTrue(max == 23514624000, "Wrong Answer");

        }
        
    }
}
